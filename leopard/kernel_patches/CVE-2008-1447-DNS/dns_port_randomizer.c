/*
 * CVE-2008-1447 DNS Port Randomization for Mac OS X Leopard (10.5)
 *
 * The Kaminsky DNS cache poisoning attack exploits predictable source ports
 * in DNS queries. This fix randomizes source ports for UDP DNS queries.
 *
 * Leopard Differences from Tiger:
 * - Uses mDNSResponder instead of lookupd
 * - Resolver library is in /usr/lib/libSystem.B.dylib
 * - launchd manages all services
 *
 * Build: gcc -dynamiclib -o dns_randomizer.dylib dns_port_randomizer.c \
 *        -framework CoreFoundation -arch ppc -arch i386 -mmacosx-version-min=10.5
 *
 * Author: Scott (Scottcjn) with Claude
 * License: MIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <dlfcn.h>
#include <pthread.h>
#include <fcntl.h>

/* Original bind function pointer */
static int (*original_bind)(int, const struct sockaddr *, socklen_t) = NULL;

/* Thread-safe random state */
static pthread_mutex_t rand_mutex = PTHREAD_MUTEX_INITIALIZER;
static unsigned int rand_state = 0;
static int entropy_fd = -1;

/* Get entropy from /dev/urandom (Leopard has this) */
static unsigned int get_entropy(void) {
    unsigned int entropy = 0;

    if (entropy_fd < 0) {
        entropy_fd = open("/dev/urandom", O_RDONLY);
    }

    if (entropy_fd >= 0) {
        read(entropy_fd, &entropy, sizeof(entropy));
    } else {
        /* Fallback: time + pid + address space randomization */
        entropy = (unsigned int)time(NULL) ^ (unsigned int)getpid() ^
                  (unsigned int)(uintptr_t)&entropy;
    }

    return entropy;
}

/* Generate random port in ephemeral range (49152-65535) */
static unsigned short random_port(void) {
    unsigned short port;

    pthread_mutex_lock(&rand_mutex);

    /* Mix in new entropy periodically */
    if ((rand_state & 0xFF) == 0) {
        rand_state ^= get_entropy();
    }

    /* Linear congruential generator with mixing */
    rand_state = rand_state * 1103515245 + 12345;
    port = 49152 + (unsigned short)((rand_state >> 16) % 16384);

    pthread_mutex_unlock(&rand_mutex);

    return port;
}

/* Interposed bind() that randomizes DNS source ports */
int randomized_bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    struct sockaddr_in modified_addr;
    const struct sockaddr_in *sin = (const struct sockaddr_in *)addr;

    /* Only process IPv4 sockets with unspecified port */
    if (addr->sa_family == AF_INET && sin->sin_port == 0) {
        int type = 0;
        socklen_t len = sizeof(type);

        /* Only randomize UDP sockets (DNS queries are UDP) */
        if (getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &type, &len) == 0 &&
            type == SOCK_DGRAM) {

            /* Copy and modify the address */
            memcpy(&modified_addr, addr, sizeof(modified_addr));
            modified_addr.sin_port = htons(random_port());

            /* Try to bind with randomized port, retry on conflict */
            int attempts = 0;
            int result;
            while (attempts < 100) {
                if (original_bind) {
                    result = original_bind(sockfd, (struct sockaddr *)&modified_addr, addrlen);
                } else {
                    result = bind(sockfd, (struct sockaddr *)&modified_addr, addrlen);
                }

                if (result == 0 || errno != EADDRINUSE) {
                    return result;
                }

                modified_addr.sin_port = htons(random_port());
                attempts++;
            }

            /* Fall through to original on failure */
        }
    }

    /* Pass through for non-UDP or failed randomization */
    if (original_bind) {
        return original_bind(sockfd, addr, addrlen);
    }
    return bind(sockfd, addr, addrlen);
}

/* Constructor: Initialize on library load */
__attribute__((constructor))
static void init_dns_randomizer(void) {
    /* Initialize random state with entropy */
    rand_state = get_entropy() ^ (unsigned int)getpid();

    /* Get original bind function */
    original_bind = dlsym(RTLD_NEXT, "bind");

    /* Log initialization (can be commented out for production) */
#ifdef DEBUG
    fprintf(stderr, "[CVE-2008-1447] DNS port randomization initialized (Leopard)\n");
#endif
}

/* Destructor: Cleanup */
__attribute__((destructor))
static void cleanup_dns_randomizer(void) {
    if (entropy_fd >= 0) {
        close(entropy_fd);
        entropy_fd = -1;
    }
}

/* DYLD interpose structure (Leopard method) */
typedef struct {
    const void *replacement;
    const void *replacee;
} interpose_t;

__attribute__((used))
static const interpose_t interposers[] __attribute__((section("__DATA,__interpose"))) = {
    { (const void *)randomized_bind, (const void *)bind }
};
