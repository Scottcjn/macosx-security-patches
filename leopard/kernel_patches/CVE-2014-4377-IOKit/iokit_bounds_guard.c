/*
 * CVE-2014-4377 IOKit Bounds Checking Guard for Leopard
 *
 * Privilege escalation via IOKit ioctl with malformed input.
 * This userspace guard intercepts IOKit calls and validates sizes.
 *
 * Note: Full kernel fix requires XNU rebuild. This mitigates
 * common attack vectors from userspace applications.
 *
 * Build: gcc -dynamiclib -o iokit_bounds_guard.dylib iokit_bounds_guard.c \
 *        -framework IOKit -framework CoreFoundation -arch ppc -arch i386 \
 *        -mmacosx-version-min=10.5
 *
 * Author: Scott (Scottcjn) with Claude
 * License: MIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <errno.h>
#include <dlfcn.h>
#include <sys/ioctl.h>
#include <mach/mach.h>

/* Maximum safe input structure size */
#define MAX_IOCTL_SIZE (1024 * 1024)  /* 1 MB */
#define MAX_SCALAR_COUNT 16
#define MAX_STRUCT_SIZE (64 * 1024)   /* 64 KB per struct */

/* Original ioctl function */
static int (*original_ioctl)(int, unsigned long, ...) = NULL;

/* Validate ioctl request */
static int validate_ioctl_request(unsigned long request, void *arg) {
    /* Check for obviously malicious sizes in common IOKit structures */

    /* Extract size from ioctl request (IOCPARM_LEN) */
    size_t size = (request >> 16) & 0x1FFF; /* IOCPARM_LEN macro */

    if (size > MAX_IOCTL_SIZE) {
        return 0;
    }

    /* Validate pointer if size > 0 */
    if (size > 0 && arg != NULL) {
        /* Basic pointer sanity - should be in userspace range
         * On 32-bit PPC, kernel starts at 0x00000000 but userspace
         * typically starts at 0x00001000 */
        uintptr_t ptr = (uintptr_t)arg;

        /* Very low addresses are usually invalid */
        if (ptr < 0x1000) {
            return 0;
        }

        /* Check for suspicious patterns that might indicate
         * a kernel address passed as userspace */
#ifdef __ppc__
        /* PPC 32-bit: addresses above 0xC0000000 are typically kernel */
        if (ptr >= 0xC0000000) {
            return 0;
        }
#endif
    }

    return 1;
}

/* Guarded ioctl */
int guarded_ioctl(int fd, unsigned long request, ...) {
    va_list ap;
    void *arg;

    va_start(ap, request);
    arg = va_arg(ap, void *);
    va_end(ap);

    /* Validate request */
    if (!validate_ioctl_request(request, arg)) {
#ifdef DEBUG
        fprintf(stderr, "[CVE-2014-4377] Blocked suspicious ioctl: fd=%d req=0x%lx\n",
                fd, request);
#endif
        errno = EINVAL;
        return -1;
    }

    if (original_ioctl) {
        return original_ioctl(fd, request, arg);
    }

    return ioctl(fd, request, arg);
}

__attribute__((constructor))
static void init_iokit_guard(void) {
    original_ioctl = dlsym(RTLD_NEXT, "ioctl");

#ifdef DEBUG
    fprintf(stderr, "[CVE-2014-4377] IOKit bounds guard active (Leopard)\n");
#endif
}

/* DYLD interpose */
typedef struct {
    const void *replacement;
    const void *replacee;
} interpose_t;

__attribute__((used))
static const interpose_t interposers[] __attribute__((section("__DATA,__interpose"))) = {
    { (const void *)guarded_ioctl, (const void *)ioctl }
};
