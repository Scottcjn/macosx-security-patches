/*
 * CVE-2010-0036 HFS+ Integer Overflow Guard for Leopard
 *
 * Integer overflow in HFS+ handling can lead to heap corruption.
 * This userspace guard intercepts file operations and validates sizes.
 *
 * Note: Full kernel fix requires XNU rebuild. This is a userspace
 * mitigation that catches common attack vectors via file operations.
 *
 * Build: gcc -dynamiclib -o hfs_overflow_guard.dylib hfs_overflow_guard.c \
 *        -framework CoreFoundation -arch ppc -arch i386 -mmacosx-version-min=10.5
 *
 * Author: Scott (Scottcjn) with Claude
 * License: MIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/param.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <dlfcn.h>

/* Maximum safe file size for HFS+ operations (2GB - 1) */
#define HFS_SAFE_SIZE_LIMIT 0x7FFFFFFF

/* Original function pointers */
static ssize_t (*original_read)(int, void *, size_t) = NULL;
static ssize_t (*original_write)(int, const void *, size_t) = NULL;
static off_t (*original_lseek)(int, off_t, int) = NULL;
static int (*original_ftruncate)(int, off_t) = NULL;

/* Check if fd is on HFS+ filesystem */
static int is_hfs_fd(int fd) {
    struct statfs buf;

    if (fstatfs(fd, &buf) == 0) {
        /* HFS+ type strings */
        if (strcmp(buf.f_fstypename, "hfs") == 0 ||
            strcmp(buf.f_fstypename, "devfs") == 0) {
            return 1;
        }
    }
    return 0;
}

/* Validate size won't cause overflow */
static int safe_size_check(size_t size, off_t offset) {
    /* Check for integer overflow in size + offset */
    if (size > HFS_SAFE_SIZE_LIMIT) {
        return 0;
    }
    if (offset > HFS_SAFE_SIZE_LIMIT) {
        return 0;
    }
    if ((off_t)size + offset < 0) { /* Overflow check */
        return 0;
    }
    if ((off_t)size + offset > HFS_SAFE_SIZE_LIMIT) {
        return 0;
    }
    return 1;
}

/* Get current offset for fd */
static off_t get_fd_offset(int fd) {
    off_t current = lseek(fd, 0, SEEK_CUR);
    if (current < 0) {
        current = 0;
    }
    return current;
}

/* Guarded read */
ssize_t guarded_read(int fd, void *buf, size_t count) {
    if (is_hfs_fd(fd)) {
        off_t offset = get_fd_offset(fd);
        if (!safe_size_check(count, offset)) {
            errno = EFBIG;
            return -1;
        }
    }

    if (original_read) {
        return original_read(fd, buf, count);
    }
    return read(fd, buf, count);
}

/* Guarded write */
ssize_t guarded_write(int fd, const void *buf, size_t count) {
    if (is_hfs_fd(fd)) {
        off_t offset = get_fd_offset(fd);
        if (!safe_size_check(count, offset)) {
            errno = EFBIG;
            return -1;
        }
    }

    if (original_write) {
        return original_write(fd, buf, count);
    }
    return write(fd, buf, count);
}

/* Guarded lseek */
off_t guarded_lseek(int fd, off_t offset, int whence) {
    if (is_hfs_fd(fd)) {
        if (offset > HFS_SAFE_SIZE_LIMIT || offset < -HFS_SAFE_SIZE_LIMIT) {
            errno = EINVAL;
            return -1;
        }
    }

    if (original_lseek) {
        return original_lseek(fd, offset, whence);
    }
    return lseek(fd, offset, whence);
}

/* Guarded ftruncate */
int guarded_ftruncate(int fd, off_t length) {
    if (is_hfs_fd(fd)) {
        if (length > HFS_SAFE_SIZE_LIMIT || length < 0) {
            errno = EFBIG;
            return -1;
        }
    }

    if (original_ftruncate) {
        return original_ftruncate(fd, length);
    }
    return ftruncate(fd, length);
}

__attribute__((constructor))
static void init_hfs_guard(void) {
    original_read = dlsym(RTLD_NEXT, "read");
    original_write = dlsym(RTLD_NEXT, "write");
    original_lseek = dlsym(RTLD_NEXT, "lseek");
    original_ftruncate = dlsym(RTLD_NEXT, "ftruncate");

#ifdef DEBUG
    fprintf(stderr, "[CVE-2010-0036] HFS+ overflow guard active (Leopard)\n");
#endif
}

/* DYLD interpose */
typedef struct {
    const void *replacement;
    const void *replacee;
} interpose_t;

__attribute__((used))
static const interpose_t interposers[] __attribute__((section("__DATA,__interpose"))) = {
    { (const void *)guarded_read, (const void *)read },
    { (const void *)guarded_write, (const void *)write },
    { (const void *)guarded_lseek, (const void *)lseek },
    { (const void *)guarded_ftruncate, (const void *)ftruncate }
};
