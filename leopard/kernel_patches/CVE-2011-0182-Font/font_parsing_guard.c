/*
 * CVE-2011-0182 Font Parsing Guard for Leopard
 *
 * Malicious font files can trigger remote code execution via
 * buffer overflows in font table parsing. This guard intercepts
 * file opens for font files and validates critical headers.
 *
 * Protects against:
 * - Malformed TrueType/OpenType fonts
 * - Integer overflow in table offsets
 * - Buffer overflow via crafted glyph data
 *
 * Build: gcc -dynamiclib -o font_parsing_guard.dylib font_parsing_guard.c \
 *        -framework CoreFoundation -arch ppc -arch i386 -mmacosx-version-min=10.5
 *
 * Author: Scott (Scottcjn) with Claude
 * License: MIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <dlfcn.h>
#include <sys/stat.h>

/* Font file magic numbers */
#define TTF_MAGIC   0x00010000
#define OTF_MAGIC   0x4F54544F  /* 'OTTO' */
#define TTC_MAGIC   0x74746366  /* 'ttcf' */
#define DFONT_MAGIC 0x00000100

/* Limits for sane font files */
#define MAX_FONT_SIZE       (50 * 1024 * 1024)  /* 50 MB max */
#define MAX_NUM_TABLES      256
#define MAX_TABLE_OFFSET    (256 * 1024 * 1024) /* 256 MB */

/* Original open functions */
static int (*original_open)(const char *, int, ...) = NULL;

/* Font extensions to check */
static const char *font_extensions[] = {
    ".ttf", ".otf", ".ttc", ".dfont", ".TTC", ".TTF", ".OTF",
    NULL
};

/* Check if path is a font file */
static int is_font_path(const char *path) {
    if (!path) return 0;

    size_t len = strlen(path);
    if (len < 4) return 0;

    const char **ext = font_extensions;
    while (*ext) {
        size_t elen = strlen(*ext);
        if (len >= elen && strcasecmp(path + len - elen, *ext) == 0) {
            return 1;
        }
        ext++;
    }
    return 0;
}

/* Read big-endian 32-bit value */
static unsigned int read_be32(const unsigned char *p) {
    return ((unsigned int)p[0] << 24) |
           ((unsigned int)p[1] << 16) |
           ((unsigned int)p[2] << 8) |
           ((unsigned int)p[3]);
}

/* Read big-endian 16-bit value */
static unsigned short read_be16(const unsigned char *p) {
    return ((unsigned short)p[0] << 8) | ((unsigned short)p[1]);
}

/* Validate font file headers */
static int validate_font_file(int fd) {
    unsigned char header[256];
    struct stat st;
    ssize_t n;

    /* Check file size */
    if (fstat(fd, &st) != 0) {
        return 0;
    }

    if (st.st_size > MAX_FONT_SIZE) {
        return 0; /* Too large */
    }

    if (st.st_size < 12) {
        return 0; /* Too small */
    }

    /* Read header */
    if (lseek(fd, 0, SEEK_SET) != 0) {
        return 0;
    }

    n = read(fd, header, sizeof(header));
    if (n < 12) {
        return 0;
    }

    /* Check magic */
    unsigned int magic = read_be32(header);
    if (magic != TTF_MAGIC && magic != OTF_MAGIC &&
        magic != TTC_MAGIC && magic != DFONT_MAGIC) {
        return 0; /* Unknown format */
    }

    if (magic == TTF_MAGIC || magic == OTF_MAGIC) {
        /* TrueType/OpenType: validate table directory */
        unsigned short numTables = read_be16(header + 4);

        if (numTables > MAX_NUM_TABLES) {
            return 0; /* Too many tables */
        }

        /* Validate each table entry if we have enough data */
        size_t needed = 12 + numTables * 16;
        if ((size_t)n >= needed || needed <= sizeof(header)) {
            unsigned char *entry = header + 12;
            int i;
            for (i = 0; i < numTables && (entry - header + 16) <= n; i++) {
                unsigned int offset = read_be32(entry + 8);
                unsigned int length = read_be32(entry + 12);

                /* Check for integer overflow */
                if (offset > MAX_TABLE_OFFSET ||
                    length > MAX_TABLE_OFFSET ||
                    (offset + length) < offset) { /* Overflow */
                    return 0;
                }

                /* Check bounds */
                if (offset + length > (unsigned int)st.st_size + 1024) {
                    return 0; /* Table extends beyond file */
                }

                entry += 16;
            }
        }
    } else if (magic == TTC_MAGIC) {
        /* TrueType Collection: validate offset table */
        unsigned int numFonts = read_be32(header + 8);

        if (numFonts > 256) {
            return 0; /* Too many fonts in collection */
        }

        /* Validate font offsets */
        if ((size_t)n >= 12 + numFonts * 4) {
            unsigned int i;
            for (i = 0; i < numFonts; i++) {
                unsigned int offset = read_be32(header + 12 + i * 4);
                if (offset > (unsigned int)st.st_size || offset > MAX_TABLE_OFFSET) {
                    return 0;
                }
            }
        }
    }

    /* Reset file position */
    lseek(fd, 0, SEEK_SET);

    return 1; /* Valid */
}

/* Guarded open() */
int guarded_open(const char *path, int flags, ...) {
    int fd;
    mode_t mode = 0;

    /* Handle mode argument if O_CREAT */
    if (flags & O_CREAT) {
        va_list ap;
        va_start(ap, flags);
        mode = va_arg(ap, int);
        va_end(ap);
    }

    /* Call original open */
    if (original_open) {
        if (flags & O_CREAT) {
            fd = original_open(path, flags, mode);
        } else {
            fd = original_open(path, flags);
        }
    } else {
        fd = -1;
        errno = ENOSYS;
        return fd;
    }

    if (fd < 0) {
        return fd;
    }

    /* Validate font files */
    if (is_font_path(path) && (flags & O_RDONLY) == O_RDONLY) {
        if (!validate_font_file(fd)) {
#ifdef DEBUG
            fprintf(stderr, "[CVE-2011-0182] Blocked malformed font: %s\n", path);
#endif
            close(fd);
            errno = ENOENT; /* Pretend file doesn't exist */
            return -1;
        }
    }

    return fd;
}

__attribute__((constructor))
static void init_font_guard(void) {
    original_open = dlsym(RTLD_NEXT, "open");

#ifdef DEBUG
    fprintf(stderr, "[CVE-2011-0182] Font parsing guard active (Leopard)\n");
#endif
}

/* DYLD interpose */
typedef struct {
    const void *replacement;
    const void *replacee;
} interpose_t;

__attribute__((used))
static const interpose_t interposers[] __attribute__((section("__DATA,__interpose"))) = {
    { (const void *)guarded_open, (const void *)open }
};
