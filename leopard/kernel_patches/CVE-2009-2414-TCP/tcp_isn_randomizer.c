/*
 * CVE-2009-2414 TCP Initial Sequence Number Randomization for Leopard
 *
 * Weak ISN generation allows TCP connection hijacking attacks.
 * This fix improves ISN randomization using hardware entropy.
 *
 * Note: Leopard has better ISN randomization than Tiger, but this
 * provides additional entropy mixing for older PowerPC systems.
 *
 * Build: gcc -dynamiclib -o tcp_isn_randomizer.dylib tcp_isn_randomizer.c \
 *        -framework CoreFoundation -arch ppc -arch i386 -mmacosx-version-min=10.5
 *
 * Author: Scott (Scottcjn) with Claude
 * License: MIT
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <dlfcn.h>

/* Entropy pool for ISN generation */
static unsigned int entropy_pool[16];
static int pool_index = 0;
static pthread_mutex_t isn_mutex = PTHREAD_MUTEX_INITIALIZER;
static int urandom_fd = -1;

/* Original connect function */
static int (*original_connect)(int, const struct sockaddr *, socklen_t) = NULL;

/* Get hardware entropy */
static void refresh_entropy_pool(void) {
    if (urandom_fd < 0) {
        urandom_fd = open("/dev/urandom", O_RDONLY | O_NONBLOCK);
    }

    if (urandom_fd >= 0) {
        /* Read entropy from /dev/urandom */
        read(urandom_fd, entropy_pool, sizeof(entropy_pool));
    } else {
        /* Fallback: use timing jitter */
        int i;
        for (i = 0; i < 16; i++) {
            struct timeval tv;
            gettimeofday(&tv, NULL);
            entropy_pool[i] ^= tv.tv_usec;
            entropy_pool[i] ^= (unsigned int)clock();
        }
    }
}

/* Generate entropy-mixed value for ISN */
static unsigned int generate_isn_entropy(void) {
    unsigned int result;

    pthread_mutex_lock(&isn_mutex);

    /* Refresh pool every 16 uses */
    if ((pool_index & 0xF) == 0) {
        refresh_entropy_pool();
    }

    /* Mix multiple pool entries */
    result = entropy_pool[pool_index & 0xF];
    result ^= entropy_pool[(pool_index + 7) & 0xF];
    result = (result << 13) | (result >> 19);
    result ^= (unsigned int)time(NULL);
    result ^= (unsigned int)getpid();

    /* Update pool with feedback */
    entropy_pool[pool_index & 0xF] = result;
    pool_index++;

    pthread_mutex_unlock(&isn_mutex);

    return result;
}

/* Interposed connect() to add entropy */
int enhanced_connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    int type = 0;
    socklen_t len = sizeof(type);

    /* Only enhance TCP connections */
    if (getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &type, &len) == 0 &&
        type == SOCK_STREAM && addr->sa_family == AF_INET) {

        /* Generate entropy that will influence the ISN
         * The kernel uses this timing as additional input */
        volatile unsigned int entropy = generate_isn_entropy();

        /* Add slight timing jitter based on entropy */
        if (entropy & 0x1) {
            usleep((entropy >> 1) & 0x1F); /* 0-31 microseconds */
        }

        /* Entropy value affects timing, which kernel uses for ISN */
        (void)entropy; /* Prevent optimization away */
    }

    if (original_connect) {
        return original_connect(sockfd, addr, addrlen);
    }
    return connect(sockfd, addr, addrlen);
}

__attribute__((constructor))
static void init_isn_randomizer(void) {
    /* Initialize entropy pool */
    refresh_entropy_pool();

    /* Get original connect */
    original_connect = dlsym(RTLD_NEXT, "connect");

#ifdef DEBUG
    fprintf(stderr, "[CVE-2009-2414] TCP ISN entropy enhanced (Leopard)\n");
#endif
}

__attribute__((destructor))
static void cleanup_isn_randomizer(void) {
    if (urandom_fd >= 0) {
        close(urandom_fd);
        urandom_fd = -1;
    }
}

/* DYLD interpose */
typedef struct {
    const void *replacement;
    const void *replacee;
} interpose_t;

__attribute__((used))
static const interpose_t interposers[] __attribute__((section("__DATA,__interpose"))) = {
    { (const void *)enhanced_connect, (const void *)connect }
};
